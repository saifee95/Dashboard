{
  "name": "d3-dsv",
  "version": "1.0.0",
  "description": "A parser and formatter for delimiter-separated values, such as CSV and TSV",
  "keywords": [
    "d3",
    "d3-module",
    "dsv",
    "csv",
    "tsv"
  ],
  "homepage": "https://d3js.org/d3-dsv/",
  "license": "BSD-3-Clause",
  "author": {
    "name": "Mike Bostock",
    "url": "http://bost.ocks.org/mike"
  },
  "main": "build/d3-dsv.js",
  "jsnext:main": "index.js",
  "bin": {
    "csv2tsv": "./bin/csv2tsv",
    "csv2json": "./bin/csv2json",
    "tsv2csv": "./bin/tsv2csv",
    "tsv2json": "./bin/tsv2json"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/d3/d3-dsv.git"
  },
  "scripts": {
    "pretest": "rm -rf build && mkdir build && rollup --banner \"$(preamble)\" -f umd -n d3 -o build/d3-dsv.js -- index.js",
    "test": "tape 'test/**/*-test.js' && eslint index.js src",
    "prepublish": "npm run test && uglifyjs --preamble \"$(preamble)\" build/d3-dsv.js -c -m -o build/d3-dsv.min.js",
    "postpublish": "VERSION=`node -e 'console.log(require(\"./package.json\").version)'`; git push && git push --tags && cp build/d3-dsv.js ../d3.github.com/d3-dsv.v1.js && cp build/d3-dsv.min.js ../d3.github.com/d3-dsv.v1.min.js && cd ../d3.github.com && git add d3-dsv.v1.js d3-dsv.v1.min.js && git commit -m \"d3-dsv ${VERSION}\" && git push && cd - && zip -j build/d3-dsv.zip -- LICENSE README.md build/d3-dsv.js build/d3-dsv.min.js"
  },
  "dependencies": {
    "rw": "1"
  },
  "devDependencies": {
    "eslint": "2",
    "package-preamble": "0.0",
    "rollup": "0.31",
    "tape": "4",
    "uglify-js": "2"
  },
  "readme": "# d3-dsv\n\nThis module provides a parser and formatter for delimiter-separated values, most commonly [comma-](https://en.wikipedia.org/wiki/Comma-separated_values) (CSV) or tab-separated values (TSV). These tabular formats are popular with spreadsheet programs such as Microsoft Excel, and are often more space-efficient than JSON. This implementation is based on [RFC 4180](http://tools.ietf.org/html/rfc4180).\n\nComma (CSV) and tab (TSV) delimiters are built-in. For example, to parse:\n\n```js\nd3.csvParse(\"foo,bar\\n1,2\"); // [{foo: \"1\", bar: \"2\"}, columns: [\"foo\", \"bar\"]]\nd3.tsvParse(\"foo\\tbar\\n1\\t2\"); // [{foo: \"1\", bar: \"2\"}, columns: [\"foo\", \"bar\"]]\n```\n\nOr to format:\n\n```js\nd3.csvFormat([{foo: \"1\", bar: \"2\"}]); // \"foo,bar\\n1,2\"\nd3.tsvFormat([{foo: \"1\", bar: \"2\"}]); // \"foo\\tbar\\n1\\t2\"\n```\n\nTo use a different delimiter, such as “|” for pipe-separated values, use [d3.dsvFormat](#dsvFormat):\n\n```js\nvar psv = d3.dsvFormat(\"|\");\n\nconsole.log(psv.parse(\"foo|bar\\n1|2\")); // [{foo: \"1\", bar: \"2\"}, columns: [\"foo\", \"bar\"]]\n```\n\nFor easy loading of DSV files in a browser, see [d3-request](https://github.com/d3/d3-request)’s [d3.csv](https://github.com/d3/d3-request#csv) and [d3.tsv](https://github.com/d3/d3-request#tsv) methods.\n\n## Installing\n\nIf you use NPM, `npm install d3-dsv`. Otherwise, download the [latest release](https://github.com/d3/d3-dsv/releases/latest). You can also load directly from [d3js.org](https://d3js.org), either as a [standalone library](https://d3js.org/d3-dsv.v1.min.js) or as part of [D3 4.0](https://github.com/d3/d3). AMD, CommonJS, and vanilla environments are supported. In vanilla, a `d3` global is exported:\n\n```html\n<script src=\"https://d3js.org/d3-dsv.v1.min.js\"></script>\n<script>\n\nvar data = d3.csvParse(string);\n\n</script>\n```\n\n[Try d3-dsv in your browser.](https://tonicdev.com/npm/d3-dsv)\n\n## API Reference\n\n<a name=\"csvParse\" href=\"#csvParse\">#</a> d3.<b>csvParse</b>(<i>string</i>[, <i>row</i>])\n\nEquivalent to [dsvFormat](#dsvFormat)(\",\").[parse](#dsv_parse).\n\n<a name=\"csvParseRows\" href=\"#csvParseRows\">#</a> d3.<b>csvParseRows</b>(<i>string</i>[, <i>row</i>])\n\nEquivalent to [dsvFormat](#dsvFormat)(\",\").[parseRows](#dsv_parseRows).\n\n<a name=\"csvFormat\" href=\"#csvFormat\">#</a> d3.<b>csvFormat</b>(<i>rows</i>[, <i>columns</i>])\n\nEquivalent to [dsvFormat](#dsvFormat)(\",\").[format](#dsv_format).\n\n<a name=\"csvFormatRows\" href=\"#csvFormatRows\">#</a> d3.<b>csvFormatRows</b>(<i>rows</i>)\n\nEquivalent to [dsvFormat](#dsvFormat)(\",\").[formatRows](#dsv_formatRows).\n\n<a name=\"tsvParse\" href=\"#tsvParse\">#</a> d3.<b>tsvParse</b>(<i>string</i>[, <i>row</i>])\n\nEquivalent to [dsvFormat](#dsvFormat)(\"\\t\").[parse](#dsv_parse).\n\n<a name=\"tsvParseRows\" href=\"#tsvParseRows\">#</a> d3.<b>tsvParseRows</b>(<i>string</i>[, <i>row</i>])\n\nEquivalent to [dsvFormat](#dsvFormat)(\"\\t\").[parseRows](#dsv_parseRows).\n\n<a name=\"tsvFormat\" href=\"#tsvFormat\">#</a> d3.<b>tsvFormat</b>(<i>rows</i>[, <i>columns</i>])\n\nEquivalent to [dsvFormat](#dsvFormat)(\"\\t\").[format](#dsv_format).\n\n<a name=\"tsvFormatRows\" href=\"#tsvFormatRows\">#</a> d3.<b>tsvFormatRows</b>(<i>rows</i>)\n\nEquivalent to [dsvFormat](#dsvFormat)(\"\\t\").[formatRows](#dsv_formatRows).\n\n<a name=\"dsvFormat\" href=\"#dsvFormat\">#</a> d3.<b>dsvFormat</b>(<i>delimiter</i>)\n\nConstructs a new DSV parser and formatter for the specified *delimiter*. The *delimiter* must be a single character (*i.e.*, a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.\n\n<a name=\"dsv_parse\" href=\"#dsv_parse\">#</a> *dsv*.<b>parse</b>(<i>string</i>[, <i>row</i>])\n\nParses the specified *string*, which must be in the delimiter-separated values format with the appropriate delimiter, returning an array of objects representing the parsed rows.\n\nUnlike [*dsv*.parseRows](#dsv_parseRows), this method requires that the first line of the DSV content contains a delimiter-separated list of column names; these column names become the attributes on the returned objects. For example, consider the following CSV file:\n\n```\nYear,Make,Model,Length\n1997,Ford,E350,2.34\n2000,Mercury,Cougar,2.38\n```\n\nThe resulting JavaScript array is:\n\n```js\n[\n  {\"Year\": \"1997\", \"Make\": \"Ford\", \"Model\": \"E350\", \"Length\": \"2.34\"},\n  {\"Year\": \"2000\", \"Make\": \"Mercury\", \"Model\": \"Cougar\", \"Length\": \"2.38\"}\n]\n```\n\nThe returned array also exposes a `columns` property containing the column names in input order (in contrast to Object.keys, whose iteration order is arbitrary). For example:\n\n```js\ndata.columns; // [\"Year\", \"Make\", \"Model\", \"Length\"]\n```\n\nIf a *row* conversion function is not specified, field values are strings. For safety, there is no automatic conversion to numbers, dates, or other types. In some cases, JavaScript may coerce strings to numbers for you automatically (for example, using the `+` operator), but better is to specify a *row* conversion function.\n\nIf a *row* conversion function is specified, the specified function is invoked for each row, being passed an object representing the current row (`d`), the index (`i`) starting at zero for the first non-header row, and the array of column names. If the returned value is null or undefined, the row is skipped and will be ommitted from the array returned by *dsv*.parse; otherwise, the returned value defines the corresponding row object. For example:\n\n```js\nvar data = d3.csvParse(string, function(d) {\n  return {\n    year: new Date(+d.Year, 0, 1), // lowercase and convert \"Year\" to Date\n    make: d.Make, // lowercase\n    model: d.Model, // lowercase\n    length: +d.Length // lowercase and convert \"Length\" to number\n  };\n});\n```\n\nNote: using `+` rather than [parseInt](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt) or [parseFloat](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseFloat) is typically faster, though more restrictive. For example, `\"30px\"` when coerced using `+` returns `NaN`, while parseInt and parseFloat return `30`.\n\n<a name=\"dsv_parseRows\" href=\"#dsv_parseRows\">#</a> <i>dsv</i>.<b>parseRows</b>(<i>string</i>[, <i>row</i>])\n\nParses the specified *string*, which must be in the delimiter-separated values format with the appropriate delimiter, returning an array of arrays representing the parsed rows.\n\nUnlike [*dsv*.parse](#dsv_parse), this method treats the header line as a standard row, and should be used whenever DSV content does not contain a header. Each row is represented as an array rather than an object. Rows may have variable length. For example, consider the following CSV file, which notably lacks a header line:\n\n```\n1997,Ford,E350,2.34\n2000,Mercury,Cougar,2.38\n```\n\nThe resulting JavaScript array is:\n\n```js\n[\n  [\"1997\", \"Ford\", \"E350\", \"2.34\"],\n  [\"2000\", \"Mercury\", \"Cougar\", \"2.38\"]\n]\n```\n\nIf a *row* conversion function is not specified, field values are strings. For safety, there is no automatic conversion to numbers, dates, or other types. In some cases, JavaScript may coerce strings to numbers for you automatically (for example, using the `+` operator), but better is to specify a *row* conversion function.\n\nIf a *row* conversion function is specified, the specified function is invoked for each row, being passed an array representing the current row (`d`), the index (`i`) starting at zero for the first row, and the array of column names. If the returned value is null or undefined, the row is skipped and will be ommitted from the array returned by *dsv*.parse; otherwise, the returned value defines the corresponding row object. For example:\n\n```js\nvar data = d3.csvParseRows(string, function(d, i) {\n  return {\n    year: new Date(+d[0], 0, 1), // convert first colum column to Date\n    make: d[1],\n    model: d[2],\n    length: +d[3] // convert fourth column to number\n  };\n});\n```\n\nIn effect, *row* is similar to applying a [map](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map) and [filter](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/filter) operator to the returned rows.\n\n<a name=\"dsv_format\" href=\"#dsv_format\">#</a> <i>dsv</i>.<b>format</b>(<i>rows</i>[, <i>columns</i>])\n\nFormats the specified array of object *rows* as delimiter-separated values, returning a string. This operation is the inverse of [*dsv*.parse](#dsv_parse). Each row will be separated by a newline (`\\n`), and each column within each row will be separated by the delimiter (such as a comma, `,`). Values that contain either the delimiter, a double-quote (`\"`) or a newline will be escaped using double-quotes.\n\nIf *columns* is not specified, the list of column names that forms the header row is determined by the union of all properties on all objects in *rows*; the order of columns is nondeterministic. If *columns* is specified, it is an array of strings representing the column names. For example:\n\n```js\nvar string = d3.csvFormat(data, [\"year\", \"make\", \"model\", \"length\"]);\n```\n\nAll fields on each row object will be coerced to strings. For more control over which and how fields are formatted, first map *rows* to an array of array of string, and then use [*dsv*.formatRows](#dsv_formatRows).\n\n<a name=\"dsv_formatRows\" href=\"#dsv_formatRows\">#</a> <i>dsv</i>.<b>formatRows</b>(<i>rows</i>)\n\nFormats the specified array of array of string *rows* as delimiter-separated values, returning a string. This operation is the reverse of [*dsv*.parseRows](#dsv_parseRows). Each row will be separated by a newline (`\\n`), and each column within each row will be separated by the delimiter (such as a comma, `,`). Values that contain either the delimiter, a double-quote (\") or a newline will be escaped using double-quotes.\n\nTo convert an array of objects to an array of arrays while explicitly specifying the columns, use [*array*.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map). For example:\n\n```js\nvar string = d3.csvFormatRows(data.map(function(d, i) {\n  return [\n    d.year.getFullYear(), // Assuming d.year is a Date object.\n    d.make,\n    d.model,\n    d.length\n  ];\n}));\n```\n\nIf you like, you can also [*array*.concat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) this result with an array of column names to generate the first row:\n\n```js\nvar string = d3.csvFormatRows([[\n    \"year\",\n    \"make\",\n    \"model\",\n    \"length\"\n  ]].concat(data.map(function(d, i) {\n  return [\n    d.year.getFullYear(), // Assuming d.year is a Date object.\n    d.make,\n    d.model,\n    d.length\n  ];\n})));\n```\n\n### Content Security Policy\n\nIf a [content security policy](http://www.w3.org/TR/CSP/) is in place, note that [*dsv*.parse](#dsv_parse) requires `unsafe-eval` in the `script-src` directive, due to the (safe) use of dynamic code generation for fast parsing. (See [source](https://github.com/d3/d3-dsv/blob/master/src/dsv.js).) Alternatively, use [*dsv*.parseRows](#dsv_parseRows).\n\n## Command Line Reference\n\nThis module comes with a few binaries to convert DSV files:\n\n* csv2json\n* csv2tsv\n* tsv2csv\n* tsv2json\n\nThese programs either take a single file as an argument or read from stdin, and write to stdout. For example, these statements are all equivalent:\n\n```\ncsv2json file.csv > file.json\ncsv2json < file.csv > file.json\ncsv2json - < file.csv > file.json\ncat file.csv | csv2json - > file.json\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/d3/d3-dsv/issues"
  },
  "_id": "d3-dsv@1.0.0",
  "dist": {
    "shasum": "697f902afe5ebe0ab1ca749150c505f5f0effb3c"
  },
  "_from": "d3-dsv@1.0.0",
  "_resolved": "https://registry.npmjs.org/d3-dsv/-/d3-dsv-1.0.0.tgz"
}
